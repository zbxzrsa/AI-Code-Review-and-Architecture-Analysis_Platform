# Common SSRF (Server-Side Request Forgery) Pattern - For Cache Warming
# This pattern should be detected as a security vulnerability

import requests
import urllib.request
from urllib.parse import urlparse

# VULNERABLE: Direct user input to requests
def fetch_url_unsafe(user_url):
    """DANGEROUS: SSRF vulnerability - can access internal services"""
    # Attacker can pass http://169.254.169.254/latest/meta-data/
    # to access AWS metadata or internal services
    response = requests.get(user_url)
    return response.text


# VULNERABLE: URL from database without validation
def fetch_webhook_unsafe(webhook_url):
    """DANGEROUS: No validation of webhook URL"""
    # Could be set to http://localhost:8080/admin
    return requests.post(webhook_url, json={"event": "test"})


# VULNERABLE: Image fetch without URL validation
def download_image_unsafe(image_url):
    """DANGEROUS: Can be used to scan internal network"""
    urllib.request.urlretrieve(image_url, "/tmp/image.jpg")


# VULNERABLE: Redirect following without checks
def fetch_with_redirects_unsafe(url):
    """DANGEROUS: Follows redirects to internal URLs"""
    # Attacker can use redirect to bypass URL checks
    response = requests.get(url, allow_redirects=True)
    return response.content


# ============================================================
# SAFE ALTERNATIVES
# ============================================================

import ipaddress
import socket


# Allowed domains whitelist
ALLOWED_DOMAINS = {
    "api.github.com",
    "api.gitlab.com",
    "hooks.slack.com",
}

# Blocked IP ranges (internal networks)
BLOCKED_RANGES = [
    ipaddress.ip_network("10.0.0.0/8"),
    ipaddress.ip_network("172.16.0.0/12"),
    ipaddress.ip_network("192.168.0.0/16"),
    ipaddress.ip_network("127.0.0.0/8"),
    ipaddress.ip_network("169.254.0.0/16"),  # Link-local / AWS metadata
    ipaddress.ip_network("0.0.0.0/8"),
]


def is_safe_url(url: str) -> bool:
    """Validate URL is safe to request"""
    try:
        parsed = urlparse(url)
        
        # Only allow http/https
        if parsed.scheme not in ("http", "https"):
            return False
        
        # Check against domain whitelist
        if ALLOWED_DOMAINS and parsed.hostname not in ALLOWED_DOMAINS:
            return False
        
        # Resolve hostname to IP
        try:
            ip = ipaddress.ip_address(socket.gethostbyname(parsed.hostname))
        except socket.gaierror:
            return False
        
        # Check against blocked IP ranges
        for blocked in BLOCKED_RANGES:
            if ip in blocked:
                return False
        
        return True
    except Exception:
        return False


# SAFE: Validate URL before fetching
def fetch_url_safe(user_url: str) -> str:
    """SAFE: Validates URL before making request"""
    if not is_safe_url(user_url):
        raise ValueError(f"URL not allowed: {user_url}")
    
    response = requests.get(
        user_url,
        allow_redirects=False,  # Don't follow redirects
        timeout=10
    )
    return response.text


# SAFE: Whitelist-based webhook validation
def fetch_webhook_safe(webhook_url: str) -> requests.Response:
    """SAFE: Only allows whitelisted domains"""
    parsed = urlparse(webhook_url)
    
    if parsed.hostname not in ALLOWED_DOMAINS:
        raise ValueError(f"Webhook domain not allowed: {parsed.hostname}")
    
    if parsed.scheme != "https":
        raise ValueError("Only HTTPS webhooks allowed")
    
    return requests.post(
        webhook_url,
        json={"event": "test"},
        timeout=10
    )


# SAFE: Image download with validation
def download_image_safe(image_url: str, output_path: str) -> None:
    """SAFE: Validates URL and content type"""
    if not is_safe_url(image_url):
        raise ValueError(f"URL not allowed: {image_url}")
    
    response = requests.get(
        image_url,
        allow_redirects=False,
        timeout=30,
        stream=True
    )
    
    # Verify content type
    content_type = response.headers.get("Content-Type", "")
    if not content_type.startswith("image/"):
        raise ValueError(f"Invalid content type: {content_type}")
    
    # Limit file size (e.g., 10MB)
    max_size = 10 * 1024 * 1024
    size = int(response.headers.get("Content-Length", 0))
    if size > max_size:
        raise ValueError(f"File too large: {size} bytes")
    
    with open(output_path, "wb") as f:
        for chunk in response.iter_content(chunk_size=8192):
            f.write(chunk)


# SAFE: Handle redirects safely
def fetch_with_redirects_safe(url: str, max_redirects: int = 3) -> bytes:
    """SAFE: Validates each redirect URL"""
    if not is_safe_url(url):
        raise ValueError(f"URL not allowed: {url}")
    
    current_url = url
    for _ in range(max_redirects):
        response = requests.get(
            current_url,
            allow_redirects=False,
            timeout=10
        )
        
        if response.status_code in (301, 302, 303, 307, 308):
            redirect_url = response.headers.get("Location")
            if not redirect_url:
                break
            
            # Validate redirect URL too
            if not is_safe_url(redirect_url):
                raise ValueError(f"Redirect URL not allowed: {redirect_url}")
            
            current_url = redirect_url
        else:
            return response.content
    
    raise ValueError("Too many redirects")
