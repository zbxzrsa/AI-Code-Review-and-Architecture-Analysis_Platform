"""
Cross-Version Feedback System

Enables V2 (Stable) to fix errors found in V1 (Experimental) and 
optimize compatibility of new technologies.

Flow:
1. V1 experiments with new technologies
2. Errors/issues are detected in V1
3. V2 analyzes errors and generates fixes
4. Fixed version is applied back to V1
5. If fix successful, technology proceeds to promotion
"""

import asyncio
import logging
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Set
import uuid

logger = logging.getLogger(__name__)


class ErrorType(str, Enum):
    """Types of errors that V2 can fix."""
    COMPATIBILITY = "compatibility"
    PERFORMANCE = "performance"
    SECURITY = "security"
    ACCURACY = "accuracy"
    STABILITY = "stability"
    INTEGRATION = "integration"


class FixStatus(str, Enum):
    """Status of a fix."""
    PENDING = "pending"
    ANALYZING = "analyzing"
    FIXING = "fixing"
    TESTING = "testing"
    APPLIED = "applied"
    VERIFIED = "verified"
    FAILED = "failed"


@dataclass
class V1Error:
    """Error detected in V1 experimentation."""
    error_id: str
    technology_id: str
    technology_name: str
    error_type: ErrorType
    description: str
    stack_trace: Optional[str] = None
    affected_code: Optional[str] = None
    metrics_at_failure: Dict[str, float] = field(default_factory=dict)
    detected_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    context: Dict[str, Any] = field(default_factory=dict)


@dataclass
class V2Fix:
    """Fix generated by V2 for a V1 error."""
    fix_id: str
    error_id: str
    fix_type: str  # patch, refactor, config_change, rollback
    description: str
    code_changes: List[Dict[str, Any]] = field(default_factory=list)
    config_changes: Dict[str, Any] = field(default_factory=dict)
    compatibility_notes: str = ""
    status: FixStatus = FixStatus.PENDING
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    applied_at: Optional[datetime] = None
    verified_at: Optional[datetime] = None
    success_metrics: Dict[str, float] = field(default_factory=dict)


@dataclass
class FeedbackRecord:
    """Record of cross-version feedback."""
    record_id: str
    from_version: str  # Usually "v1"
    to_version: str    # Usually "v2" for analysis, then back to "v1"
    error: V1Error
    fix: Optional[V2Fix] = None
    outcome: str = "pending"  # fixed, unfixable, needs_manual_review
    lessons_learned: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


class CrossVersionFeedbackSystem:
    """
    Manages cross-version feedback loop:
    V1 (errors) → V2 (analysis & fix) → V1 (apply fix) → V2 (verify)
    """
    
    def __init__(
        self,
        v2_ai_engine=None,
        version_manager=None,
        event_bus=None,
    ):
        self.v2_ai = v2_ai_engine
        self.version_manager = version_manager
        self.event_bus = event_bus
        
        # Error tracking
        self._errors: Dict[str, V1Error] = {}
        self._fixes: Dict[str, V2Fix] = {}
        self._feedback_records: Dict[str, FeedbackRecord] = {}
        
        # Pattern learning
        self._error_patterns: List[Dict[str, Any]] = []
        self._fix_templates: Dict[str, Dict[str, Any]] = {}
        
        # Locks
        self._lock = asyncio.Lock()
    
    # =========================================================================
    # Error Detection & Reporting
    # =========================================================================
    
    async def report_v1_error(
        self,
        technology_id: str,
        technology_name: str,
        error_type: ErrorType,
        description: str,
        stack_trace: Optional[str] = None,
        affected_code: Optional[str] = None,
        metrics: Optional[Dict[str, float]] = None,
        context: Optional[Dict[str, Any]] = None,
    ) -> V1Error:
        """Report an error from V1 experimentation."""
        error = V1Error(
            error_id=str(uuid.uuid4()),
            technology_id=technology_id,
            technology_name=technology_name,
            error_type=error_type,
            description=description,
            stack_trace=stack_trace,
            affected_code=affected_code,
            metrics_at_failure=metrics or {},
            context=context or {},
        )
        
        self._errors[error.error_id] = error
        
        logger.info(f"V1 Error reported: {error_type.value} in {technology_name}")
        
        # Automatically trigger V2 analysis
        await self._trigger_v2_analysis(error)
        
        if self.event_bus:
            await self.event_bus.publish("v1_error_reported", {
                "error_id": error.error_id,
                "technology": technology_name,
                "type": error_type.value,
                "timestamp": error.detected_at.isoformat(),
            })
        
        return error
    
    # =========================================================================
    # V2 Analysis & Fix Generation
    # =========================================================================
    
    async def _trigger_v2_analysis(self, error: V1Error):
        """Trigger V2 to analyze the error and generate a fix."""
        logger.info(f"Triggering V2 analysis for error {error.error_id}")
        
        # Create feedback record
        record = FeedbackRecord(
            record_id=str(uuid.uuid4()),
            from_version="v1",
            to_version="v2",
            error=error,
        )
        self._feedback_records[record.record_id] = record
        
        # Analyze error and generate fix
        fix = await self._analyze_and_generate_fix(error)
        
        if fix:
            self._fixes[fix.fix_id] = fix
            record.fix = fix
    
    async def _analyze_and_generate_fix(self, error: V1Error) -> Optional[V2Fix]:
        """V2 AI analyzes error and generates fix."""
        
        # Check for known patterns first
        template = self._find_fix_template(error)
        
        if template:
            logger.info(f"Using existing fix template for {error.error_type.value}")
            fix = await self._apply_template(error, template)
        else:
            logger.info(f"Generating new fix for {error.error_type.value}")
            fix = await self._generate_new_fix(error)
        
        if fix:
            fix.status = FixStatus.ANALYZING
        
        return fix
    
    def _find_fix_template(self, error: V1Error) -> Optional[Dict[str, Any]]:
        """Find existing fix template for similar errors."""
        error_key = f"{error.error_type.value}:{error.technology_name}"
        return self._fix_templates.get(error_key)
    
    def _apply_template(
        self,
        error: V1Error,
        template: Dict[str, Any],
    ) -> V2Fix:
        """Apply a fix template to an error."""
        return V2Fix(
            fix_id=str(uuid.uuid4()),
            error_id=error.error_id,
            fix_type=template.get("fix_type", "patch"),
            description=template.get("description", ""),
            code_changes=template.get("code_changes", []),
            config_changes=template.get("config_changes", {}),
            compatibility_notes=template.get("compatibility_notes", ""),
        )
    
    async def _generate_new_fix(self, error: V1Error) -> V2Fix:
        """Generate a new fix using V2 AI."""
        fix_strategies = await self._determine_fix_strategies(error)
        
        code_changes = []
        config_changes = {}
        compatibility_notes = []
        
        for strategy in fix_strategies:
            if strategy == "compatibility_wrapper":
                code_changes.append({
                    "type": "add_wrapper",
                    "description": "Add compatibility wrapper for new technology",
                    "target": error.technology_name,
                })
                compatibility_notes.append(
                    f"Added compatibility layer for {error.technology_name}"
                )
            
            elif strategy == "config_adjustment":
                config_changes["performance_tuning"] = {
                    "timeout_ms": 5000,
                    "retry_count": 3,
                    "fallback_enabled": True,
                }
            
            elif strategy == "error_handling":
                code_changes.append({
                    "type": "add_error_handler",
                    "description": "Add robust error handling",
                    "patterns": ["try_catch", "circuit_breaker", "graceful_degradation"],
                })
            
            elif strategy == "performance_optimization":
                code_changes.append({
                    "type": "optimize",
                    "description": "Optimize performance bottleneck",
                    "techniques": ["caching", "batching", "async_processing"],
                })
        
        return V2Fix(
            fix_id=str(uuid.uuid4()),
            error_id=error.error_id,
            fix_type="patch",
            description=f"Fix for {error.error_type.value} error in {error.technology_name}",
            code_changes=code_changes,
            config_changes=config_changes,
            compatibility_notes="\n".join(compatibility_notes),
        )
    
    async def _determine_fix_strategies(self, error: V1Error) -> List[str]:
        """Determine fix strategies based on error type."""
        strategies = []
        
        if error.error_type == ErrorType.COMPATIBILITY:
            strategies.extend(["compatibility_wrapper", "config_adjustment"])
        elif error.error_type == ErrorType.PERFORMANCE:
            strategies.extend(["performance_optimization", "config_adjustment"])
        elif error.error_type == ErrorType.SECURITY:
            strategies.extend(["error_handling", "config_adjustment"])
        elif error.error_type == ErrorType.ACCURACY:
            strategies.extend(["error_handling"])
        elif error.error_type == ErrorType.STABILITY:
            strategies.extend(["error_handling", "config_adjustment"])
        else:
            strategies.append("error_handling")
        
        return strategies
    
    # =========================================================================
    # Fix Application
    # =========================================================================
    
    async def apply_fix_to_v1(self, fix_id: str) -> bool:
        """Apply a V2-generated fix back to V1."""
        fix = self._fixes.get(fix_id)
        if not fix:
            logger.error(f"Fix {fix_id} not found")
            return False
        
        async with self._lock:
            fix.status = FixStatus.FIXING
            
            try:
                # Apply code changes
                for change in fix.code_changes:
                    await self._apply_code_change(change)
                
                # Apply config changes
                if fix.config_changes:
                    await self._apply_config_change(fix.config_changes)
                
                fix.status = FixStatus.APPLIED
                fix.applied_at = datetime.now(timezone.utc)
                
                logger.info(f"Fix {fix_id} applied to V1")
                
                # Trigger testing
                await self._test_fix(fix)
                
                return True
                
            except Exception as e:
                logger.error(f"Failed to apply fix {fix_id}: {e}")
                fix.status = FixStatus.FAILED
                return False
    
    def _apply_code_change(self, change: Dict[str, Any]):
        """Apply a code change."""
        change_type = change.get("type")
        logger.info(f"Applying code change: {change_type}")
        # In production, would modify actual code/config
    
    def _apply_config_change(self, config: Dict[str, Any]):
        """Apply configuration changes."""
        logger.info(f"Applying config changes: {list(config.keys())}")
        # In production, would update configuration
    
    # =========================================================================
    # Testing & Verification
    # =========================================================================
    
    def _test_fix(self, fix: V2Fix):
        """Test the applied fix."""
        fix.status = FixStatus.TESTING
        
        # Simulate testing
        test_results = self._run_fix_tests(fix)
        
        if test_results.get("passed", False):
            fix.status = FixStatus.VERIFIED
            fix.verified_at = datetime.now(timezone.utc)
            fix.success_metrics = test_results.get("metrics", {})
            
            # Learn from successful fix
            self._learn_from_fix(fix)
            
            logger.info(f"Fix {fix.fix_id} verified successfully")
        else:
            fix.status = FixStatus.FAILED
            logger.warning(f"Fix {fix.fix_id} failed testing")
    
    def _run_fix_tests(
        self,
        fix: V2Fix  # noqa: ARG002 - reserved for fix-specific tests
    ) -> Dict[str, Any]:
        """Run tests for the fix."""
        # In production, would run actual tests
        return {
            "passed": True,
            "metrics": {
                "accuracy": 0.92,
                "error_rate": 0.02,
                "latency_p95_ms": 2500,
            },
            "test_count": 50,
            "passed_count": 50,
        }
    
    def _learn_from_fix(self, fix: V2Fix):
        """Learn from successful fix and store as template."""
        error = self._errors.get(fix.error_id)
        if not error:
            return
        
        # Store as fix template
        template_key = f"{error.error_type.value}:{error.technology_name}"
        self._fix_templates[template_key] = {
            "fix_type": fix.fix_type,
            "description": fix.description,
            "code_changes": fix.code_changes,
            "config_changes": fix.config_changes,
            "compatibility_notes": fix.compatibility_notes,
            "success_rate": 1.0,
            "use_count": 1,
        }
        
        # Record error pattern
        self._error_patterns.append({
            "error_type": error.error_type.value,
            "technology": error.technology_name,
            "fix_strategy": fix.fix_type,
            "success": True,
        })
        
        logger.info(f"Learned fix template for {template_key}")
    
    # =========================================================================
    # Compatibility Optimization
    # =========================================================================
    
    async def optimize_compatibility(
        self,
        technology_id: str,
        target_version: str = "v2",
    ) -> Dict[str, Any]:
        """
        Optimize a V1 technology for V2 compatibility.
        
        V2's stable patterns are used to make V1 technology more compatible.
        """
        optimizations = []
        
        # Get V2 best practices
        v2_patterns = await self._get_v2_patterns()
        
        # Generate compatibility recommendations
        for pattern in v2_patterns:
            optimization = {
                "pattern": pattern["name"],
                "recommendation": f"Apply {pattern['name']} pattern for better stability",
                "priority": pattern.get("priority", "medium"),
                "estimated_improvement": pattern.get("improvement", 0.05),
            }
            optimizations.append(optimization)
        
        return {
            "technology_id": technology_id,
            "target_version": target_version,
            "optimizations": optimizations,
            "estimated_compatibility_score": 0.95,
        }
    
    def _get_v2_patterns(self) -> List[Dict[str, Any]]:
        """Get stable patterns from V2."""
        return [
            {"name": "circuit_breaker", "priority": "high", "improvement": 0.10},
            {"name": "retry_with_backoff", "priority": "high", "improvement": 0.08},
            {"name": "graceful_degradation", "priority": "medium", "improvement": 0.05},
            {"name": "health_check", "priority": "medium", "improvement": 0.05},
            {"name": "rate_limiting", "priority": "medium", "improvement": 0.03},
        ]
    
    # =========================================================================
    # Reporting
    # =========================================================================
    
    def get_feedback_statistics(self) -> Dict[str, Any]:
        """Get statistics on cross-version feedback."""
        total_errors = len(self._errors)
        total_fixes = len(self._fixes)
        
        verified_fixes = sum(
            1 for f in self._fixes.values() 
            if f.status == FixStatus.VERIFIED
        )
        failed_fixes = sum(
            1 for f in self._fixes.values() 
            if f.status == FixStatus.FAILED
        )
        
        return {
            "total_errors_reported": total_errors,
            "total_fixes_generated": total_fixes,
            "fixes_verified": verified_fixes,
            "fixes_failed": failed_fixes,
            "fix_success_rate": verified_fixes / total_fixes if total_fixes > 0 else 0,
            "fix_templates_learned": len(self._fix_templates),
            "error_patterns_recorded": len(self._error_patterns),
        }
    
    def get_pending_fixes(self) -> List[V2Fix]:
        """Get fixes pending application."""
        return [
            f for f in self._fixes.values()
            if f.status in [FixStatus.PENDING, FixStatus.ANALYZING]
        ]
    
    def get_fix_history(self, technology_id: str) -> List[FeedbackRecord]:
        """Get fix history for a technology."""
        return [
            r for r in self._feedback_records.values()
            if r.error.technology_id == technology_id
        ]
