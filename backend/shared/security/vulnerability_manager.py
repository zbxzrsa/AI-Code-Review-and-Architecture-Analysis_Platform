"""
Vulnerability Management System (R-006 Mitigation)

Provides automated vulnerability tracking with:
- Dependency scanning integration
- CVE tracking and prioritization
- SLA enforcement
- Remediation tracking
- Reporting and dashboards

Targets:
- Daily dependency scans
- Critical CVE fix within 24 hours
- High CVE fix within 7 days
- Overall CVE vulnerability rate < 5%
"""
import asyncio
import json
import logging
import os
import subprocess
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
import re

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(str, Enum):
    """CVE severity levels."""
    CRITICAL = "critical"  # CVSS >= 9.0
    HIGH = "high"          # CVSS 7.0-8.9
    MEDIUM = "medium"      # CVSS 4.0-6.9
    LOW = "low"            # CVSS < 4.0
    UNKNOWN = "unknown"


class VulnerabilityStatus(str, Enum):
    """Vulnerability status."""
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    FIXED = "fixed"
    WONT_FIX = "wont_fix"
    FALSE_POSITIVE = "false_positive"


class RemediationSLA:
    """SLA definitions for vulnerability remediation."""
    CRITICAL = timedelta(hours=24)    # 24 hours
    HIGH = timedelta(days=7)          # 7 days
    MEDIUM = timedelta(days=30)       # 30 days
    LOW = timedelta(days=90)          # 90 days

    @classmethod
    def get_sla(cls, severity: VulnerabilitySeverity) -> timedelta:
        """Get SLA for severity level."""
        sla_map = {
            VulnerabilitySeverity.CRITICAL: cls.CRITICAL,
            VulnerabilitySeverity.HIGH: cls.HIGH,
            VulnerabilitySeverity.MEDIUM: cls.MEDIUM,
            VulnerabilitySeverity.LOW: cls.LOW,
        }
        return sla_map.get(severity, cls.MEDIUM)


@dataclass
class Vulnerability:
    """Represents a vulnerability."""
    id: str
    cve_id: Optional[str]
    package_name: str
    installed_version: str
    fixed_version: Optional[str]
    severity: VulnerabilitySeverity
    cvss_score: float
    description: str
    status: VulnerabilityStatus = VulnerabilityStatus.OPEN
    discovered_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    sla_deadline: Optional[datetime] = None
    fixed_at: Optional[datetime] = None
    assignee: Optional[str] = None
    notes: str = ""
    source: str = "unknown"  # safety, npm-audit, trivy, etc.

    def __post_init__(self):
        if self.sla_deadline is None:
            sla = RemediationSLA.get_sla(self.severity)
            self.sla_deadline = self.discovered_at + sla

    @property
    def is_sla_breached(self) -> bool:
        """Check if SLA is breached."""
        if self.status in [VulnerabilityStatus.FIXED, VulnerabilityStatus.WONT_FIX, VulnerabilityStatus.FALSE_POSITIVE]:
            return False
        if self.sla_deadline:
            return datetime.now(timezone.utc) > self.sla_deadline
        return False

    @property
    def sla_remaining(self) -> Optional[timedelta]:
        """Get remaining time until SLA breach."""
        if self.sla_deadline:
            remaining = self.sla_deadline - datetime.now(timezone.utc)
            return remaining if remaining.total_seconds() > 0 else timedelta(0)
        return None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "cve_id": self.cve_id,
            "package_name": self.package_name,
            "installed_version": self.installed_version,
            "fixed_version": self.fixed_version,
            "severity": self.severity.value,
            "cvss_score": self.cvss_score,
            "description": self.description[:200],
            "status": self.status.value,
            "discovered_at": self.discovered_at.isoformat(),
            "sla_deadline": self.sla_deadline.isoformat() if self.sla_deadline else None,
            "is_sla_breached": self.is_sla_breached,
            "sla_remaining_hours": self.sla_remaining.total_seconds() / 3600 if self.sla_remaining else None,
            "fixed_at": self.fixed_at.isoformat() if self.fixed_at else None,
            "assignee": self.assignee,
            "source": self.source,
        }


@dataclass
class ScanResult:
    """Result of a vulnerability scan."""
    scan_id: str
    scan_type: str  # python, npm, docker, etc.
    timestamp: datetime
    vulnerabilities: List[Vulnerability]
    duration_seconds: float
    success: bool
    error_message: str = ""

    @property
    def vulnerability_count(self) -> Dict[str, int]:
        """Count vulnerabilities by severity."""
        counts = {s.value: 0 for s in VulnerabilitySeverity}
        for v in self.vulnerabilities:
            counts[v.severity.value] += 1
        return counts

    def to_dict(self) -> Dict[str, Any]:
        return {
            "scan_id": self.scan_id,
            "scan_type": self.scan_type,
            "timestamp": self.timestamp.isoformat(),
            "vulnerability_count": self.vulnerability_count,
            "total_vulnerabilities": len(self.vulnerabilities),
            "duration_seconds": round(self.duration_seconds, 2),
            "success": self.success,
            "error_message": self.error_message,
        }


class DependencyScanner:
    """
    Scans dependencies for vulnerabilities.

    Supports:
    - Python (safety, pip-audit)
    - JavaScript/TypeScript (npm audit)
    - Docker (trivy)
    """

    def __init__(self):
        self.scan_count = 0

    async def _run_command(
        self,
        cmd: List[str],
        timeout: int = 120,
        cwd: Optional[str] = None
    ) -> Tuple[str, str, int]:
        """Run a command asynchronously.

        Returns:
            Tuple of (stdout, stderr, returncode)
        """
        try:
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=cwd
            )
            stdout, stderr = await asyncio.wait_for(
                proc.communicate(),
                timeout=timeout
            )
            return stdout.decode(), stderr.decode(), proc.returncode or 0
        except asyncio.TimeoutError:
            proc.kill()
            await proc.wait()
            raise subprocess.TimeoutExpired(cmd, timeout)
        except FileNotFoundError:
            raise  # Re-raise to indicate command not found

    async def scan_python(self, requirements_file: str = "requirements.txt") -> ScanResult:
        """Scan Python dependencies using safety and pip-audit."""
        import time
        import uuid

        start_time = time.time()
        vulnerabilities = []
        errors = []

        # Try safety first
        try:
            stdout, _stderr, _returncode = await self._run_command(
                ["safety", "check", "-r", requirements_file, "--output", "json"],
                timeout=120,
            )

            if stdout:
                try:
                    data = json.loads(stdout)
                    for vuln in data.get("vulnerabilities", []):
                        v = Vulnerability(
                            id=f"PY-{self.scan_count:04d}-{len(vulnerabilities):03d}",
                            cve_id=vuln.get("cve"),
                            package_name=vuln.get("package_name", "unknown"),
                            installed_version=vuln.get("installed_version", "unknown"),
                            fixed_version=vuln.get("fixed_version"),
                            severity=self._parse_severity(vuln.get("severity", "unknown")),
                            cvss_score=vuln.get("cvss_score", 0.0),
                            description=vuln.get("advisory", "")[:500],
                            source="safety",
                        )
                        vulnerabilities.append(v)
                except json.JSONDecodeError:
                    pass

        except FileNotFoundError:
            errors.append("safety not installed")
        except subprocess.TimeoutExpired:
            errors.append("safety scan timed out")
        except Exception as e:
            errors.append(f"safety error: {str(e)}")

        # Also try pip-audit
        try:
            stdout, stderr, returncode = await self._run_command(
                ["pip-audit", "-r", requirements_file, "--format", "json"],
                timeout=120,
            )

            if stdout:
                try:
                    data = json.loads(stdout)
                    for pkg in data:
                        for vuln in pkg.get("vulns", []):
                            # Check if already found by safety
                            cve = vuln.get("id")
                            if any(v.cve_id == cve for v in vulnerabilities):
                                continue

                            v = Vulnerability(
                                id=f"PY-{self.scan_count:04d}-{len(vulnerabilities):03d}",
                                cve_id=cve,
                                package_name=pkg.get("name", "unknown"),
                                installed_version=pkg.get("version", "unknown"),
                                fixed_version=vuln.get("fix_versions", [None])[0] if vuln.get("fix_versions") else None,
                                severity=self._parse_severity_from_id(cve),
                                cvss_score=0.0,
                                description=vuln.get("description", "")[:500],
                                source="pip-audit",
                            )
                            vulnerabilities.append(v)
                except json.JSONDecodeError:
                    pass

        except FileNotFoundError:
            errors.append("pip-audit not installed")
        except subprocess.TimeoutExpired:
            errors.append("pip-audit scan timed out")
        except Exception as e:
            errors.append(f"pip-audit error: {str(e)}")

        self.scan_count += 1
        duration = time.time() - start_time

        return ScanResult(
            scan_id=str(uuid.uuid4())[:8],
            scan_type="python",
            timestamp=datetime.now(timezone.utc),
            vulnerabilities=vulnerabilities,
            duration_seconds=duration,
            success=len(errors) == 0,
            error_message="; ".join(errors),
        )

    async def scan_npm(self, package_dir: str = "frontend") -> ScanResult:
        """Scan npm dependencies using npm audit."""
        import time
        import uuid

        start_time = time.time()
        vulnerabilities = []
        error_message = ""

        try:
            stdout, _stderr, _returncode = await self._run_command(
                ["npm", "audit", "--json"],
                timeout=120,
                cwd=package_dir,
            )

            if stdout:
                try:
                    data = json.loads(stdout)

                    for name, details in data.get("vulnerabilities", {}).items():
                        severity = details.get("severity", "unknown")

                        v = Vulnerability(
                            id=f"NPM-{self.scan_count:04d}-{len(vulnerabilities):03d}",
                            cve_id=details.get("cve"),
                            package_name=name,
                            installed_version=details.get("range", "unknown"),
                            fixed_version=details.get("fixAvailable", {}).get("version") if isinstance(details.get("fixAvailable"), dict) else None,
                            severity=self._parse_severity(severity),
                            cvss_score=0.0,
                            description=details.get("title", "")[:500],
                            source="npm-audit",
                        )
                        vulnerabilities.append(v)
                except json.JSONDecodeError:
                    error_message = "Failed to parse npm audit output"

        except FileNotFoundError:
            error_message = "npm not installed"
        except subprocess.TimeoutExpired:
            error_message = "npm audit timed out"
        except Exception as e:
            error_message = str(e)

        self.scan_count += 1
        duration = time.time() - start_time

        return ScanResult(
            scan_id=str(uuid.uuid4())[:8],
            scan_type="npm",
            timestamp=datetime.now(timezone.utc),
            vulnerabilities=vulnerabilities,
            duration_seconds=duration,
            success=error_message == "",
            error_message=error_message,
        )

    async def scan_docker(self, image: str) -> ScanResult:
        """Scan Docker image using Trivy."""
        import time
        import uuid

        start_time = time.time()
        vulnerabilities = []
        error_message = ""

        try:
            stdout, _stderr, _returncode = await self._run_command(
                ["trivy", "image", "--format", "json", image],
                timeout=300,
            )

            if stdout:
                try:
                    data = json.loads(stdout)

                    for target in data.get("Results", []):
                        for vuln in target.get("Vulnerabilities", []):
                            v = Vulnerability(
                                id=f"DOCKER-{self.scan_count:04d}-{len(vulnerabilities):03d}",
                                cve_id=vuln.get("VulnerabilityID"),
                                package_name=vuln.get("PkgName", "unknown"),
                                installed_version=vuln.get("InstalledVersion", "unknown"),
                                fixed_version=vuln.get("FixedVersion"),
                                severity=self._parse_severity(vuln.get("Severity", "unknown")),
                                cvss_score=vuln.get("CVSS", {}).get("nvd", {}).get("V3Score", 0.0),
                                description=vuln.get("Title", "")[:500],
                                source="trivy",
                            )
                            vulnerabilities.append(v)
                except json.JSONDecodeError:
                    error_message = "Failed to parse trivy output"

        except FileNotFoundError:
            error_message = "trivy not installed"
        except subprocess.TimeoutExpired:
            error_message = "trivy scan timed out"
        except Exception as e:
            error_message = str(e)

        self.scan_count += 1
        duration = time.time() - start_time

        return ScanResult(
            scan_id=str(uuid.uuid4())[:8],
            scan_type="docker",
            timestamp=datetime.now(timezone.utc),
            vulnerabilities=vulnerabilities,
            duration_seconds=duration,
            success=error_message == "",
            error_message=error_message,
        )

    def _parse_severity(self, severity_str: str) -> VulnerabilitySeverity:
        """Parse severity string to enum."""
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "moderate": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
        }
        return severity_map.get(severity_str.lower(), VulnerabilitySeverity.UNKNOWN)

    def _parse_severity_from_id(self, cve_id: Optional[str]) -> VulnerabilitySeverity:
        """Parse severity from CVE ID (placeholder - would use NVD API)."""
        # In production, query NVD API for CVSS score
        return VulnerabilitySeverity.UNKNOWN


class VulnerabilityManager:
    """
    Main vulnerability management system.

    Features:
    - Automated scanning
    - SLA tracking
    - Prioritization
    - Reporting
    - Alert generation
    """

    def __init__(self, storage_path: Optional[str] = None):
        self.storage_path = Path(storage_path) if storage_path else None
        self.scanner = DependencyScanner()
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.scan_history: List[ScanResult] = []

    async def run_full_scan(self) -> Dict[str, ScanResult]:
        """Run all available scans."""
        results = {}

        # Python scan
        if Path("requirements.txt").exists():
            logger.info("Scanning Python dependencies...")
            results["python"] = await self.scanner.scan_python()
            self._process_scan_result(results["python"])

        # npm scan
        if Path("frontend/package.json").exists():
            logger.info("Scanning npm dependencies...")
            results["npm"] = await self.scanner.scan_npm()
            self._process_scan_result(results["npm"])

        self.scan_history.append(results.get("python"))
        self.scan_history.append(results.get("npm"))

        return results

    def _process_scan_result(self, result: ScanResult):
        """Process scan result and update vulnerability database."""
        for vuln in result.vulnerabilities:
            # Check if vulnerability already exists
            existing = self._find_existing_vulnerability(vuln)

            if existing:
                # Update if needed
                if existing.status == VulnerabilityStatus.FIXED:
                    # Re-opened vulnerability
                    existing.status = VulnerabilityStatus.OPEN
                    existing.discovered_at = vuln.discovered_at
                    existing.sla_deadline = vuln.sla_deadline
            else:
                # New vulnerability
                self.vulnerabilities[vuln.id] = vuln

    def _find_existing_vulnerability(self, vuln: Vulnerability) -> Optional[Vulnerability]:
        """Find existing vulnerability by CVE or package/version."""
        for existing in self.vulnerabilities.values():
            if vuln.cve_id and existing.cve_id == vuln.cve_id:
                return existing
            if (existing.package_name == vuln.package_name and
                existing.installed_version == vuln.installed_version):
                return existing
        return None

    def get_open_vulnerabilities(self, severity: Optional[VulnerabilitySeverity] = None) -> List[Vulnerability]:
        """Get open vulnerabilities, optionally filtered by severity."""
        vulnerabilities = [
            v for v in self.vulnerabilities.values()
            if v.status == VulnerabilityStatus.OPEN
        ]

        if severity:
            vulnerabilities = [v for v in vulnerabilities if v.severity == severity]

        # Sort by severity and SLA deadline
        severity_order = {
            VulnerabilitySeverity.CRITICAL: 0,
            VulnerabilitySeverity.HIGH: 1,
            VulnerabilitySeverity.MEDIUM: 2,
            VulnerabilitySeverity.LOW: 3,
            VulnerabilitySeverity.UNKNOWN: 4,
        }

        return sorted(vulnerabilities, key=lambda v: (
            severity_order[v.severity],
            v.sla_deadline or datetime.max.replace(tzinfo=timezone.utc)
        ))

    def get_sla_breached(self) -> List[Vulnerability]:
        """Get vulnerabilities with breached SLA."""
        return [
            v for v in self.vulnerabilities.values()
            if v.is_sla_breached
        ]

    def get_sla_at_risk(self, hours: int = 24) -> List[Vulnerability]:
        """Get vulnerabilities at risk of SLA breach."""
        threshold = datetime.now(timezone.utc) + timedelta(hours=hours)

        return [
            v for v in self.vulnerabilities.values()
            if v.status == VulnerabilityStatus.OPEN
            and v.sla_deadline
            and v.sla_deadline < threshold
            and not v.is_sla_breached
        ]

    def update_vulnerability(
        self,
        vuln_id: str,
        status: Optional[VulnerabilityStatus] = None,
        assignee: Optional[str] = None,
        notes: Optional[str] = None
    ) -> Optional[Vulnerability]:
        """Update a vulnerability."""
        vuln = self.vulnerabilities.get(vuln_id)
        if not vuln:
            return None

        if status:
            vuln.status = status
            if status == VulnerabilityStatus.FIXED:
                vuln.fixed_at = datetime.now(timezone.utc)

        if assignee:
            vuln.assignee = assignee

        if notes:
            vuln.notes = notes

        return vuln

    def calculate_metrics(self) -> Dict[str, Any]:
        """Calculate vulnerability metrics."""
        open_vulns = self.get_open_vulnerabilities()
        all_vulns = list(self.vulnerabilities.values())

        total = len(all_vulns)
        fixed = sum(1 for v in all_vulns if v.status == VulnerabilityStatus.FIXED)
        open_count = len(open_vulns)
        breached = len(self.get_sla_breached())
        at_risk = len(self.get_sla_at_risk())

        # CVE rate (vulnerabilities per 1000 dependencies, estimated)
        cve_rate = (open_count / max(total, 1)) * 100

        # Mean time to remediation (for fixed vulns)
        mttr_hours = 0
        fixed_vulns = [v for v in all_vulns if v.status == VulnerabilityStatus.FIXED and v.fixed_at]
        if fixed_vulns:
            total_hours = sum(
                (v.fixed_at - v.discovered_at).total_seconds() / 3600
                for v in fixed_vulns
            )
            mttr_hours = total_hours / len(fixed_vulns)

        return {
            "summary": {
                "total_vulnerabilities": total,
                "open": open_count,
                "fixed": fixed,
                "sla_breached": breached,
                "sla_at_risk": at_risk,
                "cve_rate_percent": round(cve_rate, 2),
                "cve_rate_passed": cve_rate < 5,  # Target: < 5%
                "mttr_hours": round(mttr_hours, 2),
            },
            "by_severity": {
                severity.value: len([v for v in open_vulns if v.severity == severity])
                for severity in VulnerabilitySeverity
            },
            "sla_compliance": {
                "total_with_sla": sum(1 for v in all_vulns if v.sla_deadline),
                "sla_met": sum(
                    1 for v in all_vulns
                    if v.status == VulnerabilityStatus.FIXED
                    and v.fixed_at and v.sla_deadline
                    and v.fixed_at <= v.sla_deadline
                ),
                "sla_breached": breached,
            },
        }

    def generate_report(self) -> Dict[str, Any]:
        """Generate comprehensive vulnerability report."""
        metrics = self.calculate_metrics()

        return {
            "generated_at": datetime.now(timezone.utc).isoformat(),
            "metrics": metrics,
            "critical_vulnerabilities": [
                v.to_dict() for v in self.get_open_vulnerabilities(VulnerabilitySeverity.CRITICAL)
            ],
            "sla_breached": [v.to_dict() for v in self.get_sla_breached()],
            "sla_at_risk": [v.to_dict() for v in self.get_sla_at_risk()],
            "recent_scans": [s.to_dict() for s in self.scan_history[-5:] if s],
        }

    def save_report(self, report: Dict[str, Any], output_path: str):
        """Save report to file."""
        with open(output_path, "w") as f:
            json.dump(report, f, indent=2)

        logger.info(f"Vulnerability report saved: {output_path}")


# CLI entry point
async def main():
    """CLI for vulnerability management."""
    import argparse

    parser = argparse.ArgumentParser(description="Vulnerability Management")
    parser.add_argument("action", choices=["scan", "report", "list"])
    parser.add_argument("--severity", "-s", choices=["critical", "high", "medium", "low"])
    parser.add_argument("--output", "-o", default="vulnerability_report.json")

    args = parser.parse_args()

    manager = VulnerabilityManager()

    if args.action == "scan":
        print("Running vulnerability scans...")
        results = await manager.run_full_scan()

        for scan_type, result in results.items():
            print(f"\n{scan_type.upper()} Scan:")
            print(f"  Vulnerabilities: {len(result.vulnerabilities)}")
            print(f"  Duration: {result.duration_seconds:.1f}s")
            if result.error_message:
                print(f"  Errors: {result.error_message}")

    elif args.action == "report":
        report = manager.generate_report()
        manager.save_report(report, args.output)
        print(f"Report saved: {args.output}")

    elif args.action == "list":
        severity = VulnerabilitySeverity(args.severity) if args.severity else None
        vulns = manager.get_open_vulnerabilities(severity)

        print(f"\nOpen Vulnerabilities ({len(vulns)}):")
        for v in vulns[:20]:
            breach_status = "üî¥ BREACHED" if v.is_sla_breached else f"‚è≥ {v.sla_remaining.days}d remaining" if v.sla_remaining else ""
            print(f"  [{v.severity.value.upper()}] {v.package_name}@{v.installed_version} - {v.cve_id or 'No CVE'} {breach_status}")


if __name__ == "__main__":
    asyncio.run(main())
