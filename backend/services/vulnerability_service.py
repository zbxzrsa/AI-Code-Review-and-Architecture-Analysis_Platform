"""
Vulnerability Service API

FastAPI service for managing automated vulnerability detection and fixing.
Integrates with the Self-Evolving Bug Fixer AI system.
"""

import asyncio
import logging
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, BackgroundTasks, Depends, HTTPException, Query, status
from pydantic import BaseModel, Field

# Import bug fixer components
import sys
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "ai_core"))

from ai_core.self_evolution.bug_fixer import (
    AutoFixCycle,
    BugCategory,
    BugFixerEngine,
    CodeFix,
    DetectedVulnerability,
    FixResult,
    FixStatus,
    Severity,
    create_auto_fix_cycle,
    create_bug_fixer,
)

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v2/vulnerabilities", tags=["vulnerabilities"])

# =============================================================================
# Pydantic Models
# =============================================================================


class VulnerabilityResponse(BaseModel):
    """Vulnerability response model."""
    vuln_id: str
    pattern_id: str
    file_path: str
    line_number: int
    column: int
    code_snippet: str
    surrounding_context: str
    severity: str
    category: str
    description: str
    detected_at: str
    fix_suggestion: Optional[str]
    confidence: float


class CodeFixResponse(BaseModel):
    """Code fix response model."""
    fix_id: str
    vuln_id: str
    file_path: str
    original_code: str
    fixed_code: str
    fix_description: str
    status: str
    applied_at: Optional[str]
    verified_at: Optional[str]
    verification_result: Optional[Dict[str, Any]]
    rollback_reason: Optional[str]


class FixResultResponse(BaseModel):
    """Fix result response model."""
    fix_id: str
    success: bool
    error: Optional[str]
    tests_passed: int
    tests_failed: int
    verification_score: float


class ScanRequest(BaseModel):
    """Scan request model."""
    file_paths: Optional[List[str]] = None
    categories: Optional[List[str]] = None
    min_severity: str = "low"


class ApplyFixRequest(BaseModel):
    """Apply fix request model."""
    vuln_ids: Optional[List[str]] = None
    auto_apply: bool = False
    backup: bool = True


class CycleStatusResponse(BaseModel):
    """Cycle status response model."""
    running: bool
    cycle_count: int
    scan_interval: int
    auto_fix_severity: str
    recent_cycles: List[Dict[str, Any]]
    summary: Dict[str, Any]


class VulnerabilitySummaryResponse(BaseModel):
    """Vulnerability summary response model."""
    total: int
    by_severity: Dict[str, int]
    by_category: Dict[str, int]
    by_file: Dict[str, int]
    fixes_generated: int
    fixes_applied: int
    fixes_verified: int


# =============================================================================
# Service State
# =============================================================================

# Global state for the vulnerability service
_bug_fixer: Optional[BugFixerEngine] = None
_auto_cycle: Optional[AutoFixCycle] = None


def get_bug_fixer() -> BugFixerEngine:
    """Get or create bug fixer instance."""
    global _bug_fixer
    if _bug_fixer is None:
        workspace_path = os.getenv(
            "WORKSPACE_PATH",
            str(Path(__file__).parent.parent.parent)
        )
        _bug_fixer = create_bug_fixer(workspace_path)
    return _bug_fixer


def get_auto_cycle() -> AutoFixCycle:
    """Get or create auto fix cycle instance."""
    global _auto_cycle
    if _auto_cycle is None:
        workspace_path = os.getenv(
            "WORKSPACE_PATH",
            str(Path(__file__).parent.parent.parent)
        )
        _auto_cycle = create_auto_fix_cycle(
            workspace_path,
            scan_interval=int(os.getenv("SCAN_INTERVAL", "3600")),
        )
    return _auto_cycle


# =============================================================================
# Helper Functions
# =============================================================================


def vuln_to_response(vuln: DetectedVulnerability) -> VulnerabilityResponse:
    """Convert vulnerability to response model."""
    return VulnerabilityResponse(
        vuln_id=vuln.vuln_id,
        pattern_id=vuln.pattern_id,
        file_path=vuln.file_path,
        line_number=vuln.line_number,
        column=vuln.column,
        code_snippet=vuln.code_snippet,
        surrounding_context=vuln.surrounding_context,
        severity=vuln.severity.value,
        category=vuln.category.value,
        description=vuln.description,
        detected_at=vuln.detected_at.isoformat(),
        fix_suggestion=vuln.fix_suggestion,
        confidence=vuln.confidence,
    )


def fix_to_response(fix: CodeFix) -> CodeFixResponse:
    """Convert fix to response model."""
    return CodeFixResponse(
        fix_id=fix.fix_id,
        vuln_id=fix.vuln_id,
        file_path=fix.file_path,
        original_code=fix.original_code,
        fixed_code=fix.fixed_code,
        fix_description=fix.fix_description,
        status=fix.status.value,
        applied_at=fix.applied_at.isoformat() if fix.applied_at else None,
        verified_at=fix.verified_at.isoformat() if fix.verified_at else None,
        verification_result=fix.verification_result,
        rollback_reason=fix.rollback_reason,
    )


def result_to_response(result: FixResult) -> FixResultResponse:
    """Convert fix result to response model."""
    return FixResultResponse(
        fix_id=result.fix_id,
        success=result.success,
        error=result.error,
        tests_passed=result.tests_passed,
        tests_failed=result.tests_failed,
        verification_score=result.verification_score,
    )


# =============================================================================
# API Endpoints
# =============================================================================


@router.get("/", response_model=List[VulnerabilityResponse])
async def list_vulnerabilities(
    severity: Optional[str] = Query(None, description="Filter by severity"),
    category: Optional[str] = Query(None, description="Filter by category"),
    file_path: Optional[str] = Query(None, description="Filter by file path"),
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> List[VulnerabilityResponse]:
    """List all detected vulnerabilities."""
    vulnerabilities = list(bug_fixer._vulnerabilities.values())
    
    # Apply filters
    if severity:
        vulnerabilities = [v for v in vulnerabilities if v.severity.value == severity]
    if category:
        vulnerabilities = [v for v in vulnerabilities if v.category.value == category]
    if file_path:
        vulnerabilities = [v for v in vulnerabilities if file_path in v.file_path]
    
    return [vuln_to_response(v) for v in vulnerabilities]


@router.get("/summary", response_model=VulnerabilitySummaryResponse)
async def get_summary(
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> VulnerabilitySummaryResponse:
    """Get vulnerability summary statistics."""
    summary = bug_fixer.get_vulnerability_summary()
    return VulnerabilitySummaryResponse(**summary)


@router.get("/{vuln_id}", response_model=VulnerabilityResponse)
async def get_vulnerability(
    vuln_id: str,
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> VulnerabilityResponse:
    """Get a specific vulnerability by ID."""
    vuln = bug_fixer._vulnerabilities.get(vuln_id)
    if not vuln:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Vulnerability {vuln_id} not found",
        )
    return vuln_to_response(vuln)


@router.post("/scan", response_model=List[VulnerabilityResponse])
async def scan_codebase(
    request: ScanRequest,
    background_tasks: BackgroundTasks,
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> List[VulnerabilityResponse]:
    """Scan codebase for vulnerabilities."""
    try:
        # Convert string categories to enums
        categories = None
        if request.categories:
            categories = [BugCategory(c) for c in request.categories]
        
        # Convert severity string to enum
        min_severity = Severity(request.min_severity)
        
        # Run scan
        vulnerabilities = await bug_fixer.scan_codebase(
            file_paths=request.file_paths,
            categories=categories,
            min_severity=min_severity,
        )
        
        return [vuln_to_response(v) for v in vulnerabilities]
        
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )
    except Exception as e:
        logger.error(f"Scan failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Scan failed",
        )


@router.get("/fixes/", response_model=List[CodeFixResponse])
async def list_fixes(
    status_filter: Optional[str] = Query(None, alias="status"),
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> List[CodeFixResponse]:
    """List all generated fixes."""
    fixes = list(bug_fixer._fixes.values())
    
    if status_filter:
        fixes = [f for f in fixes if f.status.value == status_filter]
    
    return [fix_to_response(f) for f in fixes]


@router.get("/fixes/{fix_id}", response_model=CodeFixResponse)
async def get_fix(
    fix_id: str,
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> CodeFixResponse:
    """Get a specific fix by ID."""
    fix = bug_fixer._fixes.get(fix_id)
    if not fix:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Fix {fix_id} not found",
        )
    return fix_to_response(fix)


@router.post("/fixes/generate", response_model=List[CodeFixResponse])
async def generate_fixes(
    request: ApplyFixRequest,
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> List[CodeFixResponse]:
    """Generate fixes for vulnerabilities."""
    try:
        fixes = await bug_fixer.generate_fixes(
            vuln_ids=request.vuln_ids,
            auto_apply=request.auto_apply,
        )
        return [fix_to_response(f) for f in fixes]
        
    except Exception as e:
        logger.error(f"Fix generation failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Fix generation failed",
        )


@router.post("/fixes/{fix_id}/apply", response_model=FixResultResponse)
async def apply_fix(
    fix_id: str,
    backup: bool = Query(True),
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> FixResultResponse:
    """Apply a generated fix."""
    try:
        result = await bug_fixer.apply_fix(fix_id, backup=backup)
        return result_to_response(result)
        
    except Exception as e:
        logger.error(f"Apply fix failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Apply fix failed",
        )


@router.post("/fixes/{fix_id}/verify", response_model=FixResultResponse)
async def verify_fix(
    fix_id: str,
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> FixResultResponse:
    """Verify an applied fix."""
    try:
        result = await bug_fixer.verify_fix(fix_id)
        return result_to_response(result)
        
    except Exception as e:
        logger.error(f"Verify fix failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Verify fix failed",
        )


@router.post("/fixes/{fix_id}/rollback")
async def rollback_fix(
    fix_id: str,
    reason: str = Query(...),
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> Dict[str, Any]:
    """Rollback an applied fix."""
    try:
        success = await bug_fixer.rollback_fix(fix_id, reason)
        return {"success": success, "fix_id": fix_id, "reason": reason}
        
    except Exception as e:
        logger.error(f"Rollback failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Rollback failed",
        )


# =============================================================================
# Auto-Fix Cycle Endpoints
# =============================================================================


@router.get("/cycle/status", response_model=CycleStatusResponse)
async def get_cycle_status(
    auto_cycle: AutoFixCycle = Depends(get_auto_cycle),
) -> CycleStatusResponse:
    """Get auto-fix cycle status."""
    status_data = auto_cycle.get_status()
    return CycleStatusResponse(**status_data)


@router.post("/cycle/start")
async def start_cycle(
    background_tasks: BackgroundTasks,
    auto_cycle: AutoFixCycle = Depends(get_auto_cycle),
) -> Dict[str, Any]:
    """Start the auto-fix cycle."""
    background_tasks.add_task(auto_cycle.start)
    return {"message": "Auto-fix cycle started", "status": "starting"}


@router.post("/cycle/stop")
async def stop_cycle(
    auto_cycle: AutoFixCycle = Depends(get_auto_cycle),
) -> Dict[str, Any]:
    """Stop the auto-fix cycle."""
    await auto_cycle.stop()
    return {"message": "Auto-fix cycle stopped", "status": "stopped"}


@router.post("/cycle/run-once")
async def run_cycle_once(
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> Dict[str, Any]:
    """Run a single scan and fix cycle."""
    try:
        # Scan
        vulnerabilities = await bug_fixer.scan_codebase(min_severity=Severity.CRITICAL)
        
        # Generate and apply fixes for critical issues
        fixes = await bug_fixer.generate_fixes(
            vuln_ids=[v.vuln_id for v in vulnerabilities if v.severity == Severity.CRITICAL],
            auto_apply=True,
        )
        
        return {
            "vulnerabilities_found": len(vulnerabilities),
            "fixes_generated": len(fixes),
            "fixes_applied": sum(1 for f in fixes if f.status == FixStatus.APPLIED),
            "timestamp": datetime.now(timezone.utc).isoformat(),
        }
        
    except Exception as e:
        logger.error(f"Single cycle run failed: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Cycle run failed",
        )


# =============================================================================
# Reports Endpoints
# =============================================================================


@router.get("/reports/fixes")
async def get_fix_report(
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> List[Dict[str, Any]]:
    """Get detailed fix report."""
    return bug_fixer.get_fix_report()


@router.get("/reports/audit")
async def get_audit_report(
    bug_fixer: BugFixerEngine = Depends(get_bug_fixer),
) -> Dict[str, Any]:
    """Get audit report of all vulnerability detections and fixes."""
    summary = bug_fixer.get_vulnerability_summary()
    fix_report = bug_fixer.get_fix_report()
    
    return {
        "generated_at": datetime.now(timezone.utc).isoformat(),
        "summary": summary,
        "vulnerabilities": [
            vuln_to_response(v).dict()
            for v in bug_fixer._vulnerabilities.values()
        ],
        "fixes": fix_report,
        "statistics": {
            "total_vulnerabilities": summary["total"],
            "critical_count": summary["by_severity"].get("critical", 0),
            "high_count": summary["by_severity"].get("high", 0),
            "medium_count": summary["by_severity"].get("medium", 0),
            "low_count": summary["by_severity"].get("low", 0),
            "fix_success_rate": (
                summary["fixes_verified"] / summary["fixes_applied"]
                if summary["fixes_applied"] > 0 else 0
            ),
        },
    }


# =============================================================================
# Health Check
# =============================================================================


@router.get("/health")
async def health_check() -> Dict[str, Any]:
    """Health check endpoint."""
    return {
        "status": "healthy",
        "service": "vulnerability-service",
        "timestamp": datetime.now(timezone.utc).isoformat(),
    }
